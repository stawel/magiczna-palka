\chapter{Przetwarzanie danych zebranych z odbiorników}

W ramach pracy powstało oprogramowanie uruchamiane na komputerze, którego zadaniem jest
przekształcenie surowych danych ultradźwiękowych 
z odbiornika na położenie nadajnika w przestrzeni oraz jego orientację.
Oprogramowanie podzielone zostało na trzy części: biblioteka \textit{mp3d} zajmująca się
sterowaniem odbiornika, odbieraniem sygnałów ultradźwiękowych i ich analizą, program \textit{scan.py}
wizualizujący dane w postaci obrazu trójwymiarowego oraz program \textit{save-pattern.py},
który służy do wstępnej kalibracji urządzenia.


Najistotniejszą częścią oprogramowania stanowi biblioteka \textit{mp3d}, została ona podzielona na pięć modułów:
\begin{enumerate}
 \item \textit{com.py} - moduł odpowiedzialny za komunikację z odbiornikiem
 \item \textit{find\_pattern.py} - moduł odpowiedzialny wyznaczanie odległości poprzez wyszukanie wzorca w odebranym sygnale
 \item \textit{xyz.py} - moduł odpowiedzialny za wyznaczenie pozycji i orientacji nadajnika, oraz za 
 weryfikację, czy zebrane dane odpowiadają modelowanej rzeczywistości
 \item \textit{info.py} - moduł wyświetlający informację o sile odbieranego sygnału
 \item \textit{ply.py} - moduł odpowiedzialny za eksportowanie danych do formaty \textit{.ply} 
    (Polygon File Format) obsługiwanego przez większość programów do obróbki grafiki 3D.
\end{enumerate}


\section{Komunikacja z odbiornikiem, moduł \textit{com.py}}

Za komunikację z odbiornikiem odpowiedzialny jest moduł \textit{com.py},
pracuje on w oddzielnym wątku, w którym cyklicznie wysyłane są żądania by dany głośnik na nadajniku nadał sygnał,
następnie odbierane są sygnały z trzech mikrofonów.
Ta czynność powtarzana jest dla każdego z czterech nadajników.
Zebrane dwanaście sygnałów po wstępnej filtracji przekazywane są dalej do \textit{find\_pattern.py}. Cały cykl powtarzany jest
co \SI{350}{ms}. Rysunek \ref{fig:com_output_2m} przedstawia odebrany sygnał z jednego mikrofonu przekazywany do modułu \textit{find\_pattern.py}.


\begin{figure}[h!]
    \centering
    \includegraphics[width=1.15\textwidth, trim= 47mm 0mm 0mm 0mm,clip]{com_output_2m_1}
    \includegraphics[width=1.15\textwidth, trim= 47mm 0mm 0mm 0mm,clip]{com_output_2m_2}
    \caption{Sygnał odebrany przez moduł \textit{com.py}. 
    Odległość między nadajnikiem a odbiornikiem wynosi 2 metry.
    Na górnym wykresie po prawej stronie widoczne są również sygnały odbite od ścian.
    }
    \label{fig:com_output_2m}
\end{figure}


\section{Wyznaczanie odległości, moduł \textit{find\_pattern.py}}

Moduł \textit{find\_pattern.py} odpowiada za wyznaczenie odległości pomiędzy czterema głośnikami i trzema mikrofonami.
w tym celu w każdym z 12 odebranych sygnałów (rysunek \ref{fig:com_output_2m}) wyszukiwane jest
położenie \textit{wzorca} odpowiadającego czołu nadanego sygnału.
Wzorzec początkowo wprowadzany jest podczas kalibracji, następnie jest ciągle aktualizowany 
(podmieniany z sygnałem pasującym do wzorca).

Do wyszukania \textit{wzorca} wewnątrz sygnału wykorzystana jest metoda najmniejszego błędu średniokwadratowego, mianowicie:

niech $w(t)$  dla $t = 0..n-1$ będzie szukanym \textit{wzorcem}, a $f(x)$ odebranym sygnałem,
wtedy możemy znaleźć takie $a$, że błąd średniokwadratowy $E(x)$ pomiędzy $w(t)$ i $a f(t+x)$ jest minimalny,
możemy to zapisać w postaci:
\[
  E(x) = \min_{a \in R} \{ \sum_{t=0}^{n-1}  (w(t) - a f(t+x))^2 \}
\]
zauważmy że:
\[
  E(x) = \min_{a \in R} \{ \sum_{t=0}^{n-1}  (w^2(t) -2a w(t) f(t+x) + a^2 f^2(t+x)) \}
\]
\[
  E(x) = \min_{a \in R} \{ \sum_{t=0}^{n-1}  w^2(t) -2a \sum_{t=0}^{n-1}  w(t) f(t+x) + a^2 \sum_{t=0}^{n-1} f^2(t+x) \}
\]
aby wyliczyć $E(x)$ należy zminimalizować wyrażenie w nawiasach klamrowych. Funkcja kwadratowa w postaci:
\[
  y(a) = \sum_{t=0}^{n-1}  w^2(t) -2a \sum_{t=0}^{n-1}  w(t) f(t+x) + a^2 \sum_{t=0}^{n-1} f^2(t+x)
\]
osiąga minimum dla:
\[
 a = \frac{ \sum\limits_{t=0}^{n-1}  w(t) f(t+x) }{ \sum\limits_{t=0}^{n-1} f^2(t+x) }
\]
z czego ostatecznie dostajemy:

\[
  E(x) = \sum_{t=0}^{n-1}  w^2(t)  - \frac {(\sum\limits_{t=0}^{n-1}  w(t) f(t+x) )^2 } { \sum\limits_{t=0}^{n-1} f^2(t+x)}
\]

Zauważmy, że dzięki skalowaniu sygnału $f(x)$ zamiast \textit{wzorcowa} $w(x)$
otrzymany błąd $E(x)$ nie zależy od siły odebranego sygnału co ułatwia porównanie błędów w dwóch różnych miejscach,
Zależy on jednak od siły sygnału wzorcowego, aby się od niego uniezależnić możemy wyznaczyć
błąd względny $e(x)$:
\[
  e(x) = \frac{E(x)}{\sum\limits_{t=0}^{n-1}  w^2(t)}
\]
po podstawieniu $E(x)$ dostajemy:
\[
  e(x) = 1 - \frac {(\sum\limits_{t=0}^{n-1}  w(t) f(t+x) )^2 } { \sum\limits_{t=0}^{n-1} f^2(t+x) \sum\limits_{t=0}^{n-1}  w^2(t)}
\]

Złożoność obliczeniowa wyrażenia: wyliczenie $ \sum\limits_{t=0}^{n-1}  w^2(t) $ 
jak i $\sum\limits_{t=0}^{n-1} f^2(t+x)$ wymaga jedynie liniowej liczby operacji, a 
 $\sum\limits_{t=0}^{n-1}  w(t) f(t+x) $ jest korelacją wzajemną funkcji $w(t)$ i $f(x)$, którą
 można wyliczyć w czasie $n \log(n)$ korzystając z szybkiej transformacji Fouriera \cite{bib:FFT_correlation}.
 
 Funkcję $e(x)$  można interpretować jako:
 im mniejszy błąd $e(x)$ tym większe prawdopodobieństwo, że szukany wzorzec $w$ znajduje się na pozycji $x$ w 
 odebranym sygnale $f$. 
 Wynikiem modułu \textit{find\_pattern.py} jest cała funkcja, $e(x)$ na podstawie której moduł \textit{xyz.py}
 wyznaczy pozycję głowicy w przestrzeni jak i jego orientację uwzględniając przy tym 
 kształt głowicy (nadmiarowość danych) jak i prawdopodobieństwo że znaleziony wzorzec jest na danej pozycji.
 
 Kolejnym zadaniem modułu \textit{find\_pattern.py} jest uaktualnianie \textit{wzorca}.
 Wraz ze zmianą kąta nachylenia nadajnika względem odbiornika zmienia się kształt odbieranego sygnału,
 dlatego jeśli badany sygnał zwiera szukany \textit{wzorzec} oraz spełnione są następujące warunki:
 \begin{itemize}
  \item moc sygnału pasującego do \textit{wzorca} jest wystarczająco duża
  \item błąd względny pomiędzy sygnałem a wzorcem jest mały
  \item moduł \textit{xyz.py} "uzna", że otrzymane pozycje pasują do modelowanej rzeczywistości
 \end{itemize}
to moduł uaktualni \textit{wzorzec}.
  
 Na rysunku \ref{fig:blad_korel} przedstawiono wynik przetwarzania sygnału poprzez moduł \textit{find\_pattern.py}.
 
 \begin{figure}[h!]
    \centering
    \includegraphics[width=1.15\textwidth, trim= 47mm 0mm 0mm 0mm,clip]{blad_korel}
    \caption{Sygnał przetworzony przez moduł \textit{find\_pattern.py}.}
    \label{fig:blad_korel}
\end{figure}
 

 
\section{Wyznaczanie pozycji oraz orientacji przestrzennej, moduł \textit{xyz.py}}

Zadaniem modułu \textit{xyz.py} jest wyznaczenie pozycji oraz orientacji w przestrzeni głowicy nadajnika.
Zauważymy, że moduł musi wyznaczyć trzy współrzędne $(x_1,x_2,x_3)$
oraz trzy kąty nachylenia $(\alpha_1, \alpha_2, \alpha_3)$ czyli w sumie sześć niewiadomych,
na wejściu moduł pobiera dwanaście sygnałów $e_i(x)$ dla $i=0..11$ odpowiadających prawdopodobieństwom odległości
czterech nadajników od trzech odbiorników, mamy więc dwukrotną nadmiarowość danych.
Ta nadmiarowość wykorzystywana jest do korekcji błędów podczas pomiaru odległości.
Moduł wybiera $n$ najbardziej prawdopodobnych odległości z $e_i(x)$, czyli takich $x_{ij}$ dla $j = 0...n-1$
że $e_i(x_{ij})$ jest duże, następnie sprawdza która kombinacja 
odległości jest możliwa ze względu na poprzedni pomiar (czy głowica nie przemieściła się za szybko)
oraz ze względu na kształt samej głowicy - jeśli wyznaczony kształt głowicy nie pasuje do jej rzeczywistych
rozmiarów pomiar jest odrzucany.
Tak wyznaczone $x_{ij}$ są przekazywany z powrotem do modułu \textit{find\_pattern.py} w celu odświeżenia wzorca,
oraz na ich podstawie wyznaczana jest pozycja i orientacja głowicy.

\section{Moduł \textit{info.py}}

zadaniem modułu \textit{info.py} jest wyświetlenie informacji związanych z siłą odbieranych sygnałów.

\section{Kalibracja}

Przed każdym uruchomieniem urządzenia wymagana jest kalibracja.
Kalibracja sprowadza się do ustawienia głowicy w odległości 2 metrów od odbiornika
uruchomienia urządzenia oraz zaznaczenia 12 wzorców potrzebnych do odnalezienia 
odebranego sygnału.

Rysunek \ref{fig:kalibracja_12x} przedstawia widok 12 sygnałów wraz z zaznaczonymi wzorcami.


 \begin{figure}[h!]
    \centering
    \includegraphics[width=1.12\textwidth, trim= 46mm 0mm 0mm 0mm,clip]{kalibracja_12x}
    \caption{Kalibracja, widok 12 sygnałów z zaznaczonymi wzorcami}
    \label{fig:kalibracja_12x}
\end{figure}

\section{Obsługa programu \textit{scan.py}}

Do obsługi prototypu służy program \textit{scan.py}, po jego uruchomieniu 
na monitorze wyświetlają się trzy okna: 
\begin{itemize}
 \item widok 3D, na którym zaznaczona jest 
pozycja nadajnika, cztery punkty reprezentujące głośniki nadajnika oraz trzy wektory normalne reprezentujące 
jego orientację, rysunek \ref{fig:widok3d}
 \item widok 2D, na którym widać nałożone na siebie dwa rzuty prostopadłe nadajnika na płaśczyzny XY i XZ, rysunek \ref{fig:widok2d}
 \item widok informujący o sile odbieranego sygnału oraz o błędzie pomiędzy \textit{wzorcem} a sygnałem, rysunek \ref{fig:power}
\end{itemize}

\rysunek{3d}{Widok 3D}{\label{fig:widok3d}}
\rysunek{2d}{Widok 2D}{\label{fig:widok2d}}
\rysunek{power}{Widok informujący o mocy sygnału oraz błędzie pomiędzy \textit{wzorcem} a sygnałem}{\label{fig:power}}

