\chapter{Przetwarzanie danych zebranych z odbiorników}

Najważniejszą częścią prototypu jest oprogramowanie, które przekształca surowe dane dźwiękowe
z odbiornika na położenie nadajnika w przestrzeni oraz jego orientację.

Przetwarzaniem danych zajmuje się biblioteka \textit{mp3d}
oraz program \textit{scan.py} wizualizujący dane w postaci obrazu trójwymiarowego.

Biblioteka \textit{mp3d} została podzielona na pięć modułów:
\begin{enumerate}

 \item \textit{com.py} - moduł odpowiedzialny za komunikację odbiornikiem
 \item \textit{find\_pattern.py} - moduł odpowiedzialny za wyszukanie wzorca w odebranym sygnale
 \item \textit{xyz.py} - moduł odpowiedzialny za wyznaczenie pozycji i orientacji nadajnika, oraz za 
 weryfikację, czy zebrane dane odpowiadają rzeczywistości
 \item \textit{info.py} - moduł wyświetlający informację o sile odbieranego sygnału
 \item \textit{ply.py} - moduł odpowiedzialny za eksportowanie danych do formaty \textit{.ply} 
    (Polygon File Format) obsługiwanego przez większość programów do obróbki grafiki 3D.

\end{enumerate}


\section{Moduł \textit{com.py}}

Zadaniem modułu \textit{com.py} jest komunikacja poprzez port USB odbiornikiem,
moduł pracuje w oddzielnym wątku, w którym cyklicznie wysyła żądanie by dany głośnik nadał sygnał, następnie odbiera
sygnał z trzech mikrofonów.
Ta czynność powtarzana jest dla każdego z czterech nadajników. 
Zebrane dwanaście sygnałów po wstępnej filtracji przekazywane są dalej do \textit{find\_pattern.py}. Cały cykl powtarzany jest
co 200ms. Rysunek \ref{fig:com_output_2m} przedstawia sygnał z jednego mikrofonu przekazywany do modułu \textit{find\_pattern.py}.


\begin{figure}[h!]
    \centering
    \includegraphics[width=1.15\textwidth, trim= 47mm 0mm 0mm 0mm,clip]{com_output_2m_1}
    \includegraphics[width=1.15\textwidth, trim= 47mm 0mm 0mm 0mm,clip]{com_output_2m_2}
    \caption{sygnał odebrany przez moduł \textit{com.py}. 
    Odległość między nadajnikiem a odbiornikiem wynosi 2 metry.
    Na górnym wykresie po prawej stronie widoczne są również sygnały odbite od ścian.
    }
    \label{fig:com_output_2m}
\end{figure}


\section{Moduł \textit{find\_pattern.py}}

Głównym modułem biblioteki \textit{mp3d} jest moduł \textit{find\_pattern.py}.
Odpowiada on za znalezienie \textit{wzorca} w odebranym sygnale.
Odbierane sygnały zmieniają się nieznacznie podczas pracy skanera (głównie gdy kąt nachylenia nadajnika względem odbiornika się zmienia)
dlatego wzorzec początkowo wprowadzony jest podczas kalibracji następnie jest ciągle aktualizowany jeśli odebrany sygnał ma wystarczającą moc.
Do wyszukania wzorca wewnątrz sygnału wykorzystana jest metoda najmniejszego błędu średniokwadratowego.

Niech $w(t)$  dla $t = 0..n-1$ będzie szukanym wzorcem, a $f(x)$ odebranym sygnałem,
wtedy możemy znaleźć takie $a$, że błąd średniokwadratowy pomiędzy $w(t)$ i $a f(t+x)$ jest minimalny, mianowicie:
\[
  E(x) = \min_{a \in R} \{ \sum_{t=0}^{n-1}  (w(t) - a f(t+x))^2 \}
\]
gdzie $E(x)$ jest bezwzględnym błędem średniokwadratowym, zauważmy że:
\[
  E(x) = \min_{a \in R} \{ \sum_{t=0}^{n-1}  (w^2(t) -2a w(t) f(t+x) + a^2 f^2(t+x)) \}
\]
\[
  E(x) = \min_{a \in R} \{ \sum_{t=0}^{n-1}  w^2(t) -2a \sum_{t=0}^{n-1}  w(t) f(t+x) + a^2 \sum_{t=0}^{n-1} f^2(t+x) \}
\]
funkcja kwadratowa w postaci:
\[
  y(a) = \sum_{t=0}^{n-1}  w^2(t) -2a \sum_{t=0}^{n-1}  w(t) f(t+x) + a^2 \sum_{t=0}^{n-1} f^2(t+x)
\]
osiąga minimum dla:
\[
 a = \frac{ \sum\limits_{t=0}^{n-1}  w(t) f(t+x) }{ \sum\limits_{t=0}^{n-1} f^2(t+x) }
\]
z czego ostatecznie dostajemy:

\[
  E(x) = \sum_{t=0}^{n-1}  w^2(t)  - \frac {(\sum\limits_{t=0}^{n-1}  w(t) f(t+x) )^2 } { \sum\limits_{t=0}^{n-1} f^2(t+x)}
\]

Zauważmy, że dzięki skalowaniu sygnału $f(x)$ zamiast sygnał wzorcowy $w(x)$
otrzymany błąd $E(x)$ nie zależy od siły odebranego sygnału, co ułatwia porównanie błędów w dwóch różnych miejscach,
Zależy on jednak od siły sygnału wzorcowego, aby się od niego uniezależnić możemy wyznaczyć
błąd względny:
\[
  e(x) = \frac{E(x)}{\sum\limits_{t=0}^{n-1}  w^2(t)}
\]

\[
  e(x) = 1 - \frac {(\sum\limits_{t=0}^{n-1}  w(t) f(t+x) )^2 } { \sum\limits_{t=0}^{n-1} f^2(t+x) \sum\limits_{t=0}^{n-1}  w^2(t)}
\]

Ponadto wyliczenie $ \sum\limits_{t=0}^{n-1}  w^2(t) $ 
jak i $\sum\limits_{t=0}^{n-1} f^2(t+x)$ wymaga jedynie liniowej liczby operacji, a 
 $\sum\limits_{t=0}^{n-1}  w(t) f(t+x)  $ jest korelacją wzajemną funkcji $w(t)$ i $f(x)$, którą
 można wyliczyć w czasie $n \log(n)$ korzystając z szybkiej transformacji Fouriera \cite{bib:FFT_correlation}.
 
 Funkcję $e(x)$  można ją interpretować jako:
 im mniejszy błąd $e(x)$ tym większe prawdopodobieństwo, że szukany wzorzec $w$ znajduje się na pozycji $x$ w 
 odebranym sygnale $f$. 
 Wynikiem modułu \textit{find\_pattern.py} jest cała funkcja, $e(x)$ na podstawie której moduł \textit{xyz.py}
 wyznaczy pozycję głowicy w przestrzeni jak i jego orientację uwzględniając przy tym 
 kształt głowicy (nadmiarowość danych) jak i prawdopodobieństwa że znaleziony wzorzec jest na danej pozycji.
 
 Kolejną zadaniem modułu \textit{find\_pattern.py} jest uaktualnianie wzorca z biegiem czasu.
 Wraz ze zmianą kąta nachylenia nadajnika względem odbiornika zmienia się znacząco kształt odbieranego sygnału,
 dlatego jeśli odnajdziemy szukany wzorzec, którego moc sygnału jest wystarczająco silna to
 podmieniany jest na niego wzorzec.
 
 Na rysunku \ref{fig:blad_korel} przedstawiony jest wynik przetwarzania sygnału przez moduł \textit{find\_pattern.py}.
 
 \begin{figure}[h!]
    \centering
    \includegraphics[width=1.15\textwidth, trim= 47mm 0mm 0mm 0mm,clip]{blad_korel}
    \caption{sygnał przetworzony przez moduł \textit{find\_pattern.py}.}
    \label{fig:blad_korel}
\end{figure}
 

 
\section{Moduł \textit{xyz.py}}

Zadaniem modułu \textit{xyz.py} jest wyznaczenie pozycji oraz orientacji w przestrzeni głowicy nadajnika.
Zauważymy, że moduł musi wyznaczyć trzy współrzędne $(x_1,x_2,x_3)$
oraz trzy kąty nachylenia $(\alpha_1, \alpha_2, \alpha_3)$ czyli w sumie sześć niewiadomych.
Na wejściu moduł pobiera dwanaście sygnałów $e_i(x)$ dla $i=0..11$ odpowiadających prawdopodobieństwom odległości
czterech nadajników od trzech odbiorników, mamy więc dwukrotną nadmiarowość danych.
Ta nadmiarowość wykorzystywana jest do korekcji błędów podczas pomiaru odległości.
Moduł wybiera $n$ najbardziej prawdopodobnych odległości z $e_i(x)$, czyli takich $x_ij$ dla $j = 0...n-1$
że $e_i(x_ij)$ jest duże, następnie sprawdza która kombinacja 
odległości jest możliwa ze względu na poprzedni pomiar (czy głowica nie przemieściła się za szybko)
oraz ze względu na kształt samej głowicy - jeśli wyznaczony kształt głowicy nie pasuje do jej rzeczywistych
rozmiarów pomiar jest odrzucany.
Tak wyznaczone $x_ij$ są przekazywany z powrotem do modułu \textit{find\_pattern.py} w celu odświeżenia wzorca,
oraz na ich podstawie wyznaczana jest pozycja i orientacja głowicy.

\section{Moduł \textit{info.py}}

zadaniem modułu \textit{info.py} jest wyświetlenie informacji związanych z siłą odbieranych sygnałów.

\section{Kalibracja}

Przed każdym uruchomieniem urządzenia wymagana jest kalibracja.
Kalibracja sprowadza się do ustawienia głowicy w odległości 2 metrów od odbiornika
uruchomienia urządzenia oraz zaznaczenia 12 wzorców potrzebnych do odnalezienia 
odebranego sygnału.
Program na podstawie odległości i czasu dodarcia sygnału wylicza prędkość dźwięku 
w danym środowisku. Co ciekawe, wypadkową wyliczonej prędkości jest temperatura otoczenia.

Rysunek \ref{fig:blad_korel} przedstawia widok 12 sygnałów wraz z zaznaczonymi wzorcami.




