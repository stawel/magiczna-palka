
\chapter{Przetwarzanie danych zebranych z~odbiornika}

W ramach niniejszej pracy powstało oprogramowanie, którego zadaniem jest
przekształcenie surowych danych ultradźwiękowych 
z odbiornika na informację o położeniu nadajnika w przestrzeni oraz jego orientacji.
Na oprogramowanie składają się biblioteka \textit{mp3d} zajmująca się
sterowaniem odbiornikiem, odbieraniem sygnałów ultradźwiękowych i ich analizą, program \textit{scan.py}
wizualizujący dane w postaci obrazu trójwymiarowego oraz program \textit{save-pattern.py},
który służy do wstępnej kalibracji urządzenia.

Najistotniejszą częścią oprogramowania jest biblioteka \textit{mp3d} podzielona na pięć modułów:
\begin{itemize}
 \item \textit{com.py} --  odpowiedzialny za komunikację z odbiornikiem,
 \item \textit{find\_pattern.py} --  odpowiedzialny za wyznaczanie odległości przez wyszukanie wzorca w~odebranym sygnale,
 \item \textit{xyz.py} --  odpowiedzialny za wyznaczenie pozycji i orientacji nadajnika oraz  weryfikujący, 
 czy zebrane dane odpowiadają modelowanej rzeczywistości,
 \item \textit{info.py} --  odpowiedzialny za wyświetlanie informacji o sile odbieranego sygnału,
 \item \textit{ply.py} --  odpowiedzialny za eksportowanie danych do formatu \textit{.ply},
    (Polygon File Format) obsługiwanego przez większość programów do obróbki grafiki 3D.
\end{itemize}


\section{Komunikacja z odbiornikiem, moduł \textit{com.py}}

Za komunikację z odbiornikiem odpowiada moduł \textit{com.py}.
Pracuje on w oddzielnym wątku, w~którym cyklicznie wysyłane są żądania, by dany głośnik nadał sygnał,
a~następnie odbierane są sygnały z trzech mikrofonów.
Ten proces odbywa się sukcesywnie dla każdego z~czterech głośników nadajnika.
Odstęp pomiędzy kolejno nadanymi sygnałami wynosi \SI{87}{ms}
co pozwala na całkowite rozproszenie się fali dźwiękowej tak by nie wpływała ona na kolejne.

Zebrane w ten sposób dwanaście sygnałów po wstępnej filtracji przekazywane są dalej do \textit{find\_pattern.py}. Cały cykl powtarza 
się co \SI{350}{ms}.
Rysunek \ref{fig:com_output_2m} przedstawia sygnał odebrany z jednego z mikrofonów.
Odebrany sygnał znacząco różni się od sygnału nadanego (rysunek \ref{fig:output_signal}),
jest to spowodowane tym, że wykorzystane mikrofony jak i głośniki są rezonatorami, dodatkowo 
ich obudowy są pudłami rezonansowymi.


\begin{figure}[p]
    \centering
    \includegraphics[width=1.0\textwidth, trim= 50mm 0mm 40mm 0mm,clip]{com_output_2m_1}
    \includegraphics[width=1.0\textwidth, trim= 50mm 0mm 40mm 0mm,clip]{com_output_2m_2}
    \caption{Sygnał odebrany przez moduł \textit{com.py}. 
    Odległość między nadajnikiem a odbiornikiem wynosi 2 metry.
    Na górnym wykresie między 6 i \SI{8}{ms} widać właściwy sygnał (poruszający się po linii prostej), od \SI{8.5}{ms}
   widać sygnał odbity od podłogi. 
    Dolny wykres jest powiększeniem górnego wykresu.}
    \label{fig:com_output_2m}
\end{figure}

\section{Wyznaczanie odległości, moduł \textit{find\_pattern.py}}

Moduł \textit{find\_pattern.py} odpowiada za obliczenie odległości pomiędzy czterema głośnikami i~trzema mikrofonami.
Wyznaczana jest ona przez wyszukanie w każdym z 12 odebranych sygnałów  położenia \textit{wzorca}, który 
odpowiada czołu nadanego sygnału (rysunek \ref{fig:com_output_2m}).
\textit{Wzorzec} po raz pierwszy wprowadzany jest podczas kalibracji, następnie 
podczas pracy urządzenia jest on ciągle aktualizowany.

W celu wyszukania \textit{wzorca} wewnątrz sygnału korzysta się z  metody najmniejszego błędu średniokwadratowego.
Niech $w(x)$  dla $x = 0, ..., n-1$ będzie szukanym \textit{wzorcem}, a $f(t)$ dla $t = 0, ..., m-1$ odebranym sygnałem.
Wtedy możemy znaleźć takie $a$, że błąd średniokwadratowy $E(t)$ pomiędzy $w(x)$ i $a f(t+x)$ jest minimalny.
Możemy to zapisać w postaci
\[
  E(t) = \min_{a \in R} \{ \sum_{x=0}^{n-1}  \left( w(x) - a f(t+x) \right) ^2 \}.
\]
Po podniesieniu wyrażenia w nawiasie do kwadratu otrzymujemy
\[
  E(t) = \min_{a \in R} \{ \sum_{x=0}^{n-1}  \left( w^2(x) -2a w(x) f(t+x) + a^2 f^2(t+x) \right) \},
\]
\[
  E(t) = \min_{a \in R} \{ \sum_{x=0}^{n-1}  w^2(x) -2a \sum_{x=0}^{n-1}  w(x) f(t+x) + a^2 \sum_{x=0}^{n-1} f^2(t+x) \}.
\]
Aby wyliczyć $E(t)$, należy zminimalizować wyrażenie
\[
  y(a) = \sum_{x=0}^{n-1}  w^2(x) -2a \sum_{x=0}^{n-1}  w(x) f(t+x) + a^2 \sum_{x=0}^{n-1} f^2(t+x).
\]
Korzystając z faktu, że $y(a)$ jest funkcją kwadratową, możemy wyliczyć $a$ minimalizujące $y(a)$
\[
  a = \frac{ \sum\limits_{x=0}^{n-1}  w(x) f(t+x) }{ \sum\limits_{x=0}^{n-1} f^2(t+x) }.
\]
Ostatecznie dostajemy wzór na $E(t)$
\[
  E(t) = \sum_{x=0}^{n-1}  w^2(x)  - \frac {\left(\sum\limits_{x=0}^{n-1}  w(x) f(t+x) \right)^2 } { \sum\limits_{x=0}^{n-1} f^2(t+x)}.
\]

Zauważmy, że dzięki skalowaniu skalarem $a$  sygnału $f(t)$, a nie \textit{wzorca} $w(x)$,
otrzymane $E(t)$ nie zależy od siły odebranego sygnału. Ułatwia to porównanie błędów w dwóch różnych miejscach.
$E(t)$ zależy jednak od siły sygnału wzorcowego -- możemy się od niego  uniezależnić, wyznaczając
błąd względny $e(t)$
\[
  e(t) = \frac{E(t)}{\sum\limits_{x=0}^{n-1}  w^2(x)}.
\]
Po podstawieniu $E(t)$ dostajemy
\[
  e(t) = 1 - \frac {\left(\sum\limits_{x=0}^{n-1}  w(x) f(t+x) \right)^2 } { \sum\limits_{x=0}^{n-1} f^2(t+x) \sum\limits_{x=0}^{n-1}  w^2(x)}.
\]
 
 Funkcję $e(t)$  można interpretować następująco:
 im mniejszy błąd $e(t)$, tym większe prawdopodobieństwo, że szukany \textit{wzorzec} $w$ znajduje się na pozycji $t$ w 
 odebranym sygnale $f$. 

 Wynikiem obliczeń modułu \textit{find\_pattern.py} jest cała funkcja $e(t)$, na podstawie której moduł \textit{xyz.py}
 wyznacza pozycję i orientację nadajnika, uwzględniając przy tym 
 jego kształt (nadmiarowość danych), a także prawdopodobieństwo, że znaleziony \textit{wzorzec} znajduje się w określonej pozycji.
 Rysunek \ref{fig:blad_korel} przedstawia wynik przetwarzania sygnału przez moduł \textit{find\_pattern.py}.

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\textwidth, trim= 50mm 0mm 40mm 0mm,clip]{blad_korel}
    \caption{Sygnał przetworzony przez moduł \textit{find\_pattern.py}}
    \label{fig:blad_korel}
\end{figure}
 
 
 Wyliczenie zarówno $ \sum\limits_{x=0}^{n-1}  w^2(x) $,
jak i $\sum\limits_{x=0}^{n-1} f^2(t+x)$ wymaga jedynie liniowej liczby operacji, a 
 $\sum\limits_{x=0}^{n-1}  w(x) f(t+x) $ jest korelacją wzajemną funkcji $w(x)$ i $f(t)$, którą
 można wyliczyć w~czasie $k \log(k)$, korzystając z szybkiej transformacji Fouriera \cite{bib:FFT_correlation},
 gdzie $k = \max \{|f|, |w| \} = \max \{n,m\}$. Wyliczenie całej funkcji $e(t)$ wymaga zatem jedynie $k \log(k)$ operacji.

 
 Kolejnym zadaniem modułu \textit{find\_pattern.py} jest uaktualnianie \textit{wzorca}.
 Wraz ze zmianą kąta nachylenia nadajnika względem odbiornika zmienia się kształt odbieranego sygnału,
 dlatego jeśli badany sygnał $f(t)$ zawiera szukany \textit{wzorzec} na pozycji $t_w$ 
 oraz spełnione są następujące warunki:
 \begin{itemize}
  \item moc sygnału $f(t_w), ..., f(t_w+n-1)$ jest wystarczająco duża,
  \item błąd względny $e(t_w)$ pomiędzy sygnałem a \textit{wzorcem} jest mały,
  \item moduł \textit{xyz.py} rozpozna otrzymaną pozycję $t_w$ jako pasuje do modelowanej rzeczywistości
 \end{itemize}
to moduł uaktualni \textit{wzorzec} do wartości $f(t_w), ..., f(t_w+n-1)$.
 
 
\section{Wyznaczanie pozycji oraz orientacji przestrzennej, moduł \textit{xyz.py}}

Na ostatnim etapem obliczeń wyznaczane są współrzędne kartezjańskie czterech głośników umieszczonych na nadajniku.
Zajmuje się tym moduł \textit{xyz.py}, który dodatkowo zawiera prosty model rzeczywistości
wyłapujący niepoprawne dane o położeniu głośników.
Model zawiera informacje o aktualnym położeni czterech głośników w przestrzeni, co umożliwia wychwycenie 
zmiany geometrii nadajnika (niepoprawne odległości pomiędzy głośnikami).

Współrzędne głośników wyznacza się na podstawie dwunastu funkcji $e_{ij}(t)$ dla $i=1, ..., 4$ oraz $j=1, ..., 3$,
w których zawarta jest informacja o odległości pomiędzy głośnikiem $i$ oraz mikrofonem $j$.
Dla danej funkcji $e_{ij}(t)$ wyszukiwane są wszystkie wartości $t_m$, dla których funkcja przyjmuje minimum lokalne.
Następnie z $t_m$ wybierane są trzy punkty $t_{m_1}, t_{m_2}, t_{m_3}$, dla których wartość $e_{ij}(t_m)$ jest najmniejsza,
czyli spełniony jest  warunek:
\[ e_{ij}(t_{m_1}) \leq e_{ij}(t_{m_2}) \leq e_{ij}(t_{m_3}) \leq e_{ij}(t_m) \qquad \text{dla} \quad m \ne m_1,m_2,m_3. \]

Pozycje $t_{m_1}, t_{m_2}, t_{m_3}$  można interpretować jako trzy najbardziej prawdopodobne odległości 
pomiędzy głośnikiem, a mikrofonem.

Do wyliczenia położenia głośników w przestrzeni wykorzystywane są wszystkie możliwe kombinacje 
trzech możliwych odległości dla dwunastu funkcji $e_{ij}$.
Daje to $12^3 = 1728$ możliwych lokalizacji głośników w przestrzeni, 
każda z nich sprawdzana jest czy pasuje do modelu (czy uzyskana geometria przestrzenna nadajnika zgadza się z
modelem). Z tych które pasują wybierana jest lokalizacja o najmniejszym sumarycznym błędzie średniokwadratowym.

Ostatecznym wynikiem pracy modułu \textit{xyz.py} jest dwanaście wartości $t_{m_k}$ gdzie $k\in \{1,2,3\}$, 
które określają nam pozycję głośników w przestrzeni.

Wartości $t_{m_k}$ przekazywane są również z powrotem do modułu \textit{find\_pattern.py} w celu aktualizacji \textit{wzorców}.


\section{Kalibracja}

Po każdym uruchomieniu urządzenie wymagana kalibracji,
która sprowadza się do ustawienia nadajnika w odległości 2 metrów od odbiornika,
uruchomienia programu \textit{save-pattern.py} oraz zaznaczenia w nim 12 obszarów  będącym czołem odebranego sygnału.
Obszary te wykorzystane zostaną jako \textit{wzorce} podczas mierzenia odległości.
Program wyliczy także aktualną prędkość dźwięku, uwzględniając odległość nadajnika od odbiornika.

Rysunek \ref{fig:kalibracja_12x} przedstawia 12 sygnałów wraz z zaznaczonymi wzorcami.


 \begin{figure}[ht]
    \centering
    \includegraphics[width=1.0\textwidth, trim= 50mm 0mm 40mm 0mm,clip]{kalibracja_12x}
    \caption{Kalibracja, 12 sygnałów z zaznaczonymi \textit{wzorcami}}
    \label{fig:kalibracja_12x}
\end{figure}

\newpage

\section{Obsługa programu \textit{scan.py}}

Do obsługi prototypu służy program \textit{scan.py}. Po jego uruchomieniu 
na monitorze wyświetlają się trzy okna: 
\begin{itemize}
 \item widok 3D prezentujący położenie nadajnika w przestrzeni -- w oknie widoczne są  
 cztery punkty reprezentujące głośniki nadajnika oraz trzy prostopadłe względem siebie wektory określające 
jego orientację i położenie (rysunek \ref{fig:widok3d}),
 \item widok 2D, również przestawiające położenie nadajnika w przestrzeni --
 są to nałożone na siebie rzuty na płaszczyzny XY i XZ
 (rysunek \ref{fig:widok2d}),
 \item diagram informujący o mocy całego odebranego sygnału, mocy \textit{wzorca}, mocy sygnału pasującego do \textit{wzorca} 
 oraz błędzie pomiędzy \textit{wzorcem} a odebranym sygnałem (rysunek \ref{fig:power}).
\end{itemize}

Wszelkie zmiany położenia nadajnika automatycznie odświeżają wszystkie widoki. 
Podczas uruchamiania programu aktualne położenie nadajnika przyjmowane 
jest jako początek układu współrzędnych.
Jeśli któryś z głośników straci widoczność z mikrofonami, obraz przestaje się odświeżać, a informacja, dlaczego tak
się dzieje, widoczna jest w oknie przedstawiającym moc sygnału.


\rysunekHT{3d}{Widok 3D}{\label{fig:widok3d}}
\rysunekHT{2d}{Widok 2D}{\label{fig:widok2d}}
\rysunekHT{power}{Diagram informujący o mocy całego odebranego sygnału, mocy \textit{wzorca}, mocy sygnału pasującego do \textit{wzorca} 
 oraz błędzie pomiędzy \textit{wzorcem} a odebranym sygnałem}{\label{fig:power}}

